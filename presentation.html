<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>BlackMail - Presentación</title>

    <meta name="description" content="Presentación sobre mi proyecto de final de Grado de Desarrollo de Aplicaciones Multiplataforma">
    <meta name="author" content="Andrés brugarolas">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
    <div class="reveal">
        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section>
                <h1>BlackMail</h1>
                <h3>Un cliente de Google Mail.</h3>
                <p>
                    <small>Hecho por <a href="https://github.com/Brugarolas">Andrés Brugarolas Martínez</a> / <a href="mailto:brugarolas.92@gmail.com">brugarolas.92@gmail.com</a>. </small>
                    <small>Presentación hecha con reveal.js.</small>
                </p>
            </section>

            <section>
                <h2>BlackMail</h2>
                <p>
                    BlackMail es un cliente de Gmail creado únicamente con tecnologías web (HTML, CSS y Javascript) y la API de Google.
                    Para tener una aplicación de escritorio independiente del navegador se ha utilizado node-webkit (más recientemente
                    renombrado NW.js).
                </p>
            </section>

            <section>
                <h2>¿Por qué tecnologías web?</h2>
                <section>
                    <p>
                        No es extraño preguntarse por qué se han utilizado tecnologías web en lugar de otras alternativas, ya que éstas cuentan
                        con numerosas desventajas, entre las que destaca el poco rendimiento que ofrecen. A continuación veremos algunos de los
                        motivos por los que se decidió así.
                    </p>
                </section>

                <section>
                    <h4>Independencia de la plataforma</h4>
                    <p>
                        El combo HTML, CSS y JS es completamente independiente de la plataforma, y por tanto goza de una excelente portabilidad,
                        siendo el único factor limitante que la plataforma cuente con un navegador web.
                    </p>
                </section>

                <section>
                    <h4>Excelentes herramientas</h4>
                    <p>
                        Se cuenta con excelentes herramientas para diseñar y depurar aplicaciones web, empezando por los propios navegadores.
                        El diseño de aplicaciones es muy rápido y sencillo. La programación es, en general, más productiva que con otros lenguajes.
                    </p>
                </section>

                <section>
                    <h4>Diseño de interfaz</h4>
                    <p>
                        Con HTML y CSS se pueden diseñar interfaces bonitas que se adaptan a cualquier tipo de pantalla, ofreciendo una gran
                        versatilidad y flexibilidad en cuanto al diseño. Esto se puede hacer de forma muy sencilla utilizando las propias
                        herramientas que los navegadores de escritorio nos ofrecen, como el Inspector o el Editor de estilos.
                    </p>
                </section>

                <section>
                    <h4>Librerías y frameworks</h4>
                    <p>
                        Al tratarse de una tecnología relativamente madura, existen numerosos frameworks y librerías para ayudarnos en el
                        desarrollo. Algunos ejemplos que hemos utilizado son AngularJS, Bootstrap, o Less.js.
                    </p>
                </section>
            </section>

            <section>
                <h2>Centrado en escritorio</h2>
                <section>
                    <p>
                        Aunque se ha tratado de darle un diseño adaptativo, BlackMail es una aplicación enfocada en el escritorio. Para eliminar
                        la dependencia del navegador y disfrutar de otras ventajas, se ha utilizado NW.js. A continuación veremos algunas de las razones:
                    </p>
                </section>
                <section>
                    <h4>Escaso rendimiento</h4>
                    <p>
                        El principal motivo es que, al ser una aplicación que hace un uso intensivo de JavaScript, el rendimiento en dispositivos móviles
                        es bastante pobre. Y aunque en terminales de gama alta funciona a la perfección, en terminales más modestos es inutilizable.
                    </p>
                </section>
                <section>
                    <h4>Falta de alternativas</h4>
                    <p>
                        Además, para dispositivos móviles existen otras alternativas gratuitas, mientras que para PC no hay ningún cliente que aproveche
                        las características que nos ofrece la API de Google, sino que suelen protocolos más generales como IMAP o POP3.
                    </p>
                </section>
            </section>

            <section>
                <h2>¿Por qué la API de Google?</h2>
                <section>
                    <p>
                        ¿Por qué se ha utilizado la API de Google y no otros protocolos específicos para el correo como POP3 o IMAP? A continuación
                        veremos algunas de las razones que me han llevado a tomar esa decisión en el diseño.
                    </p>
                </section>
                <section>
                    <h4>Demasiadas alternativas</h4>
                    <p>
                        Actualmente existen muchísimas alternativas de escritorio que se decantan por los protocolos de correo tradicionales. Sin embargo,
                        no hay ni una sola alternativa que utilize la API de Google.
                    </p>
                </section>
                <section>
                    <h4>Sencillez</h4>
                    <p>
                        Utilizar la API de Google es realmente sencillo. Con una simple función haces llamadas al servidor pidiendo datos, y la respuesta
                        es tratada automáticamente por la API para convertirla en un JSON con el que es muy fácil trabajar.
                    </p>
                </section>
                <section>
                    <h4>Integración con otros servicios</h4>
                    <p>
                        Al utilizar la API de Google, es muy sencillo integrar nuestro cliente de Gmail con otros servicios de Google como Google Drive, Google+,
                        Google Calendar o Hangouts para generar valor añadido.
                    </p>
                </section>
            </section>

            <section>
                <h2>Pero también tiene sus desventajas...</h2>
                <section>
                    <p>
                        La API de Google también tiene sus desventajas. Las principales las comentaremos a continuación:
                    </p>
                </section>
                <section>
                    <h4>Inestabilidad</h4>
                    <p>
                        La API de Google todavía se encuentra en alpha, una fase de desarrollo temprana. Por tanto es propensa a tener diversos
                        errores siendo, en general, inestable. Además una parte de la funcionalidad todavía está por implementar.
                    </p>
                </section>
                <section>
                    <h4>Cuotas</h4>
                    <p>
                        La API de Google tiene cuotas de uso, a no ser que el desarrollador las aumente pagando, tanto en términos generales como en
                        número de peticiones por segundo. Es por tanto necesario tener esto en cuenta cuando desarrollamos nuestra aplicación.
                    </p>
                </section>
                <section>
                    <h4>Código ofuscado</h4>
                    <p>
                        El código está ofuscado y por tanto es muy difícil para un desarrollador comprenderlo, extenderlo, corregir sus errores o en general
                        modificarlo a su gusto. Esto puede jugar un papel muy negativo, pues el no comprender la librería que estamos utilizando
                        puede llevarnos a cometer errores de diseño.
                    </p>
                </section>
            </section>

            <section>
                <h2>Cómo funciona la API de Google</h2>
                <section>
                    <p>Creamos la petición con:</p>
                    <p>func = gapi.client.<strong>nombreAPI</strong>.users.<strong>nombreRecurso</strong>.<strong>funcion</strong></p>
                </section>
                <section>
                    <p>Ejecutamos la petición:</p>
                    <p>func.execute(<strong>nombreFuncionCallback</strong>)</p>
                </section>
                <section>
                    <p>
                        La petición se convertirá en una objeto XMLHttpRequest, añadiendo automáticamente todos los metadatos necesarios como la
                        autenticación, y se enviará al servidor de Google.
                    </p>
                </section>
                <section>
                    <p>
                        El servidor de Google procesará la petición, y nos enviará la respuesta de vuelta. La API tratará la respuesta y la convertirá
                        en un objeto JSON con los datos solicitados.
                    </p>
                </section>
                <section>
                    <p>
                        La API de Google ejecutará entonces la función callback pasada como parámetro, pasando como parámetro la respuesta
                        del servidor ya tratada y convertida a JSON.
                    </p>
                </section>
                <section>
                    <p>Un ejemplo sencillo:</p>
                    <pre><code data-trim contenteditable>
gapi.client.gmail.users.threads.get({
    'userId': this.email,
    'id': id,
    'format': 'full'
}).execute(callback);
                    </code></pre>
                </section>
                <section>
                    <p>
                        Es posible agrupar hasta 100 solicitudes, así como especificar qué campos
                        no queremos obtener con el atributo 'fields' para conseguir un rendimiento mejor.
                    </p>
                    <pre><code data-trim contenteditable>
var batchRequest = gapi.client.newBatch();
for (var i in threadIds) {
    batchRequest.add(
        gapi.client.gmail.users.threads.get({
            'userId': this.email,
            'id': threadIds[i],
            'format': 'metadata'
        }), {'id': threadIds[i]}
    );
}
batchRequest.execute(callback, error);
                    </code></pre>
                </section>
            </section>

            <section>
                <h2>Recursos de Gmail</h2>
                <section>
                    <p>
                        La API de Gmail tiene una serie de recursos de los cuales ofrece una serie de funciones tales como
                        listar todos sus elementos, obtener un elemento concreto, eliminarlo, o modificarlo. A continuación
                        veremos cuáles son estos recursos con los que podemos trabajar.
                    </p>
                </section>
                <section>
                    <h4>Hilos (<span style="font-style: italic;">threads</span>)</h4>
                    <p>
                        Es el elemento principal con el que trabajaremos. Un hilo engloba todos los mensajes de un
                        mismo asunto.
                    </p>
                </section>
                <section>
                    <h4>Mensajes (<span style="font-style: italic;">messages</span>)</h4>
                    <p>Su nombre lo indica todo. Un mensaje es un correo electrónico enviado a uno o más destinatarios.</p>
                </section>
                <section>
                    <h4>Borradores (<span style="font-style: italic;">drafts</span>)</h4>
                    <p>Es un mensaje que aún no ha sido enviado, probablemente se encuentre a medio escribir.</p>
                </section>
                <section>
                    <h4>Adjunto (<span style="font-style: italic;">attachment</span>)</h4>
                    <p>
                        Es un fichero de hasta 25MB que se envía junto a un mensaje. Para que no se necesiten tantos recursos
                        al visualizar un mensaje con adjuntos, estos cuentan con su propio recurso.
                    </p>
                </section>
                <section>
                    <h4>Etiquetas (<span style="font-style: italic;">labels</span>)</h4>
                    <p>
                        Metainformación de un hilo que determina a las categorías a las que pertenece (enviados, recibidos, social,
                        notificaciones, etcétera).
                    </p>
                </section>
                <section>
                    <h4>Historia (<span style="font-style: italic;">attachment</span>)</h4>
                    <p>
                        Recurso asociado a las últimas actividades que has efectuado (leer un hilo, enviar un mensaje, etcétera).
                        Cada elemento de historia tiene un tiempo de vida de entre unas horas y dos o tres semanas.
                    </p>
                </section>
            </section>

            <section>
                <h2>Cómo funciona BlackMail</h2>
                <section>
                    <p>A continuación veremos, de forma muy resumida, cómo funciona nuestra aplicación. Se ha tratado de
                    hacer un diseño por capas.</p>
                </section>
                <section>
                    <h4>Plantilla HTML y CSS</h4>
                    <p>
                        Lo principal es señalar que la interfaz de la aplicación está realizada utilizando un fichero HTML
                        y su hoja de estilos CSS. En realidad, para facilitar el desarrollo de los estilos se ha utilizado
                        LESS.
                    </p>
                </section>
                <section>
                    <h4>Controllador con Angular.js</h4>
                    <p>
                        Para rellenar la plantilla con datos útiles hemos utilizado Angular.js, el cual solicita datos a la
                        capa inferior, que hemos denominado 'sistema', y los actualiza en la interfaz cuando es necesario.
                    </p>
                </section>
                <section>
                    <h4>Capa de sistema</h4>
                    <p>
                        Consta de dos subsistemas: almacenamiento y red. Su objeto es gestionar ambas capas de forma invisible
                        al controlador a la hora de gestionar los diversos recursos.
                    </p>
                </section>
                <section>
                    <h4>Sistema: ejemplo</h4>
                    <p>
                        Por ejemplo, si queremos leer un hilo concreto, llamaremos a la capa 'sistema' preguntándole por ese hilo.
                        La capa sistema comprobará si se encuentra almacenado, y si lo está lo devolverá desde la capa de almacenamiento.
                        Si no lo está, hará una llamada utilizando la capa de red, y antes de devolver los datos al controlador,
                        los almacenará.
                    </p>
                </section>
                <section>
                    <h4>Sistema: otro ejemplo</h4>
                    <p>
                        Otro ejemplo: si queremos eliminar o modificar un hilo, la capa sistema hará la petición por medio de la capa de red,
                        y si se recibe una respuesta positiva del servidor, entonces el elemento se eliminará o modificará también
                        en la capa de almacenamiento.
                    </p>
                </section>
                <section>
                    <h4>Capa de red</h4>
                    <p>
                        Encapsula las llamadas con la API de Google para hacerlas más sencillas de utilizar desde la capa de
                        sistema.
                    </p>
                </section>
                <section>
                    <h4>Capa de almacenamiento</h4>
                    <p>
                        Ofrece estructuras de datos eficientes para almacenar y gestionar en memoria la mayoría de datos de la aplicación,
                        así como métodos para persistir la información necesaria y no tener que sincronizar el cliente con cada
                        ejecución.
                    </p>
                </section>
            </section>

            <section>
                <h2>Otras librerías utilizadas</h2>
                <section>
                    <p>
                        Además de las librerías mencionadas (LESS.js, AngularJS, API de Google, reveal.js), BlackMail utiliza
                        otras librerías y frameworks que también merecen ser mencionadas.
                    </p>
                </section>
                <section>
                    <h4>Bootstrap (por Twitter)</h4>
                    <p>
                        Framework CSS que ayuda mucho en la elaboración de un diseño adaptativo.
                    </p>
                </section>
                <section>
                    <h4>Prefixfree (por Lea Verou)</h4>
                    <p>
                        Librería JavaScript que elimina la necesidad de incluir sentencias CSS específicas para cada navegador.
                    </p>
                </section>
                <section>
                    <h4>Base64 (por Dan Kogai)</h4>
                    <p>
                        Librería JavaScript para codificar y descodificar en base64, codificación utilizada en mensajes y adjuntos
                        en la API de Google.
                    </p>
                </section>
                <section>
                    <h4>Perfect Scrollbar (por Noraesae)</h4>
                    <p>
                        Sustituye las horrorosas barras de desplazamiento nativas por unas mucho más bonitas y modernas,
                        unificando la experiencia en los distintos sistemas operativos y navegadores.
                    </p>
                </section>
                <section>
                    <h4>Lo-Dash (por el equipo de Lo-Dash)</h4>
                    <p>
                        Ofrece distintas funciones muy bien optimizadas para manipular grandes cantidades de datos o programar
                        algoritmos complejos.
                    </p>
                </section>
                <section>
                    <h4>LZ-String (por Pieroxy)</h4>
                    <p>
                        Comprime y descomprime elementos JSON para un almacenamiento óptimo en localStorage.
                    </p>
                </section>
            </section>

        </div>
    </div>

    <script src="js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // Full list of configuration options available at:
        // https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'slide', // none/fade/slide/convex/concave/zoom

            // Optional reveal.js plugins
            dependencies: [
                { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                { src: 'plugin/zoom-js/zoom.js', async: true },
                { src: 'plugin/notes/notes.js', async: true }
            ]
        });
    </script>
</body>
</html>